"""update video calibration background models

Revision ID: 7b85d191618c
Revises: 33687d08c0df
Create Date: 2025-12-02 10:26:58.293351

"""
from typing import Sequence, Union

from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision: str = '7b85d191618c'
down_revision: Union[str, Sequence[str], None] = '33687d08c0df'
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    """Upgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    # Drop collection_time columns from calibrations and backgrounds if they exist
    # Check if columns exist before dropping (SQLite doesn't support IF EXISTS for DROP COLUMN)
    conn = op.get_bind()
    inspector = sa.inspect(conn)
    
    # Check and drop collection_time from backgrounds
    backgrounds_columns = [col["name"] for col in inspector.get_columns("backgrounds")]
    if "collection_time" in backgrounds_columns:
        op.drop_column("backgrounds", "collection_time")

    # Check and drop collection_time from calibrations
    calibrations_columns = [col["name"] for col in inspector.get_columns("calibrations")]
    if "collection_time" in calibrations_columns:
        op.drop_column("calibrations", "collection_time")
    
    # Add new columns to videos table with nullable first, then update and make non-nullable
    # This allows migration even if there's existing data
    op.add_column('videos', sa.Column('studio', sa.String(), nullable=True))
    op.add_column('videos', sa.Column('producer', sa.String(), nullable=True))
    op.add_column('videos', sa.Column('production', sa.String(), nullable=True))
    op.add_column('videos', sa.Column('action', sa.String(), nullable=True))
    op.add_column('videos', sa.Column('camera_count', sa.Integer(), nullable=True))
    op.add_column('videos', sa.Column('prime_camera_number', sa.Integer(), nullable=True))
    op.add_column('videos', sa.Column('background_id', sa.Integer(), nullable=True))
    op.add_column('videos', sa.Column('calibration_id', sa.Integer(), nullable=True))
    op.add_column('videos', sa.Column('frame_count', sa.Integer(), nullable=True))
    op.add_column('videos', sa.Column('frame_rate', sa.Float(), nullable=True))
    op.add_column('videos', sa.Column('frame_width', sa.Integer(), nullable=True))
    op.add_column('videos', sa.Column('frame_height', sa.Integer(), nullable=True))
    op.add_column('videos', sa.Column('tos_path', sa.String(), nullable=True))
    
    # Set default values for existing rows (if any)
    op.execute("UPDATE videos SET studio = 'default' WHERE studio IS NULL")
    op.execute("UPDATE videos SET producer = 'default' WHERE producer IS NULL")
    op.execute("UPDATE videos SET production = 'default' WHERE production IS NULL")
    op.execute("UPDATE videos SET action = 'default' WHERE action IS NULL")
    op.execute("UPDATE videos SET camera_count = 0 WHERE camera_count IS NULL")
    op.execute("UPDATE videos SET prime_camera_number = 0 WHERE prime_camera_number IS NULL")
    op.execute("UPDATE videos SET frame_count = 0 WHERE frame_count IS NULL")
    op.execute("UPDATE videos SET frame_rate = 0.0 WHERE frame_rate IS NULL")
    op.execute("UPDATE videos SET frame_width = 0 WHERE frame_width IS NULL")
    op.execute("UPDATE videos SET frame_height = 0 WHERE frame_height IS NULL")
    op.execute("UPDATE videos SET tos_path = '' WHERE tos_path IS NULL")
    
    # Note: SQLite doesn't support ALTER COLUMN, so we can't change nullable constraint
    # The columns will remain nullable in SQLite, but the application will enforce non-null
    
    # Note: SQLite doesn't support adding foreign key constraints via ALTER TABLE
    # Foreign keys are defined at table creation time. Since we're adding columns to an existing table,
    # we skip creating foreign key constraints here. The application will enforce referential integrity.
    
    # Drop old columns (SQLite requires recreating table for column drops)
    # For SQLite, we'll use a workaround: create new table, copy data, drop old, rename new
    # But since this is a breaking change, we'll just drop the columns directly
    # If there's data, user should backup first
    op.drop_column('videos', 'storage_path')
    op.drop_column('videos', 'filename')
    op.drop_column('videos', 'description')
    # ### end Alembic commands ###


def downgrade() -> None:
    """Downgrade schema."""
    # ### commands auto generated by Alembic - please adjust! ###
    op.add_column('videos', sa.Column('description', sa.TEXT(), nullable=True))
    op.add_column('videos', sa.Column('filename', sa.VARCHAR(), nullable=False))
    op.add_column('videos', sa.Column('storage_path', sa.VARCHAR(), nullable=False))
    op.drop_constraint(None, 'videos', type_='foreignkey')
    op.drop_constraint(None, 'videos', type_='foreignkey')
    op.drop_column('videos', 'tos_path')
    op.drop_column('videos', 'frame_height')
    op.drop_column('videos', 'frame_width')
    op.drop_column('videos', 'frame_rate')
    op.drop_column('videos', 'frame_count')
    op.drop_column('videos', 'calibration_id')
    op.drop_column('videos', 'background_id')
    op.drop_column('videos', 'prime_camera_number')
    op.drop_column('videos', 'camera_count')
    op.drop_column('videos', 'action')
    op.drop_column('videos', 'production')
    op.drop_column('videos', 'producer')
    op.drop_column('videos', 'studio')
    op.add_column('calibrations', sa.Column('collection_time', sa.DATETIME(), nullable=False))
    op.add_column('backgrounds', sa.Column('collection_time', sa.DATETIME(), nullable=False))
    # ### end Alembic commands ###
